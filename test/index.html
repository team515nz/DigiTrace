<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××¢×¨×›×ª × ×™×ª×•×— ×—×¤×™×¨×•×ª ××¨×›×™××•×œ×•×’×™×•×ª 3D</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸº ××¢×¨×›×ª × ×™×ª×•×— ×—×¤×™×¨×•×ª ××¨×›×™××•×œ×•×’×™×•×ª 3D</h1>
            <p>×”×¢×œ××ª ××•×“×œ×™× ×ª×œ×ª-×××“×™×™× ×•× ×™×ª×•×— ×©×›×‘×•×ª ×—×¤×™×¨×” â€¢ ×™×™×©×•×¨ ×’××™×© ×¢× ××¡×¤×¨ × ×§×•×“×•×ª</p>
        </div>

        <div class="content">
            <div class="sidebar">
                <div class="upload-section">
                    <h3>ğŸ“ ×”×¢×œ××ª ××•×“×œ×™×</h3>
                    <div class="upload-box" id="uploadBox" onclick="document.getElementById('fileInput').click()">
                        <div class="upload-icon">ğŸ“¤</div>
                        <div>×œ×—×¥ ×œ×”×¢×œ××ª ×§×•×‘×¥ 3D</div>
                        <small class="text-muted">
                            OBJ, STL, GLB, GLTF
                            <span class="format-badge">NEW</span>
                        </small>
                    </div>
                    <div id="loadingMessage" class="loading-message hidden"></div>
                    <input type="file" id="fileInput" class="file-input" accept=".obj,.stl,.glb,.gltf" multiple>
                </div>

                <div class="upload-section">
                    <h3>ğŸ“‹ ××•×“×œ×™× ×©×”×•×¢×œ×•</h3>
                    <div id="modelList" class="model-list"></div>
                </div>

                <div class="upload-section hidden" id="downloadSection">
                    <h3>ğŸ“¥ ×”×•×¨×“×ª ××•×“×œ ××©×•×œ×‘</h3>
                    <div class="download-box">
                        <select id="exportFormat" class="format-select">
                            <option value="stl">STL</option>
                            <option value="obj">OBJ</option>
                            <option value="glb">GLB</option>
                            <option value="gltf">GLTF</option>
                        </select>
                        <button class="download-btn" onclick="downloadCombinedModel()">
                            ğŸ“¥ ×”×•×¨×“ ××•×“×œ ××©×•×œ×‘
                        </button>
                    </div>
                </div>

                <div class="upload-section hidden" id="alignSection">
                    <div class="align-section">
                        <h4>ğŸ¯ ×™×™×©×•×¨ ××•×“×œ×™× ×’××™×©</h4>
                        <div class="align-controls">
                            <div class="align-info" id="alignStatus">
                                ×œ×—×¥ ×¢×œ ğŸ“ ×œ×™×“ ××•×“×œ ×•×‘×—×¨ × ×§×•×“×•×ª ×¢×œ×™×•
                            </div>
                            <div class="point-counter" id="pointCounter">
                                ××•×“×œ 1: 0 × ×§×•×“×•×ª | ××•×“×œ 2: 0 × ×§×•×“×•×ª
                            </div>
                            <button class="align-action-btn hidden" id="finishModelBtn" onclick="finishCurrentModel()">
                                ×¡×™×™× ××•×“×œ × ×•×›×—×™ â†’
                            </button>
                            <button class="align-action-btn hidden" id="undoPointBtn" onclick="undoLastPoint()">
                                â†¶ ××—×§ × ×§×•×“×” ××—×¨×•× ×”
                            </button>
                            <button class="align-execute-btn" id="executeAlignBtn" onclick="executeAlignment()" disabled>
                                ×™×™×©×¨ ××•×“×œ×™×
                            </button>
                            <button class="align-execute-btn cancel-btn" onclick="cancelAlignment()">
                                ×‘×™×˜×•×œ
                            </button>
                        </div>
                    </div>
                </div>

                <!-- ××“×™×“×ª ××¨×—×§ -->
                <div class="upload-section">
                    <h3>ğŸ“ ××“×™×“×ª ××¨×—×§</h3>
                    <button class="measure-btn" onclick="toggleMeasureMode()" id="measureBtn">
                        ğŸ¯ ×”×ª×—×œ ××“×™×“×”
                    </button>
                    <div id="measureInfo" class="measure-info hidden">
                        <div id="measureStatus">×‘×—×¨ × ×§×•×“×” ×¨××©×•× ×”...</div>
                        <div id="measureDistance" class="measure-distance"></div>
                    </div>
                </div>
            </div>

            <div class="main-content">
                <div class="controls">
                    <button class="fullscreen-btn" onclick="toggleFullscreen()">ğŸ–µ ××¡×š ××œ×</button>
                    
                    <div class="control-group">
                        <label>
                            <span class="value-display" id="cutYValue">×—×™×ª×•×š ×× ×›×™: 0%</span>
                            ×—×™×ª×•×š ××œ××¢×œ×” ×œ××˜×”
                        </label>
                        <input type="range" id="cutY" class="slider" min="0" max="100" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="cutXValue">×—×™×ª×•×š ×¨×•×—×‘: 0%</span>
                            ×—×™×ª×•×š ××©×××œ ×œ×™××™×Ÿ
                        </label>
                        <input type="range" id="cutX" class="slider" min="0" max="100" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="cutZValue">×—×™×ª×•×š ×¢×•××§: 0%</span>
                            ×—×™×ª×•×š ×××—×•×¨×” ×œ×§×“×™××”
                        </label>
                        <input type="range" id="cutZ" class="slider" min="0" max="100" value="0">
                    </div>

                    <!-- ×‘×§×¨×•×ª ×¡×™×‘×•×‘ -->
                    <div class="section-divider">×¡×™×‘×•×‘ ×”××•×“×œ</div>
                    
                    <div class="control-group">
                        <label>
                            <span class="value-display" id="rotXValue">×¡×™×‘×•×‘ X: 0Â°</span>
                            ×¡×™×‘×•×‘ ×¡×‘×™×‘ ×¦×™×¨ X
                        </label>
                        <input type="range" id="rotX" class="slider" min="0" max="360" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="rotYValue">×¡×™×‘×•×‘ Y: 0Â°</span>
                            ×¡×™×‘×•×‘ ×¡×‘×™×‘ ×¦×™×¨ Y
                        </label>
                        <input type="range" id="rotY" class="slider" min="0" max="360" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="rotZValue">×¡×™×‘×•×‘ Z: 0Â°</span>
                            ×¡×™×‘×•×‘ ×¡×‘×™×‘ ×¦×™×¨ Z
                        </label>
                        <input type="range" id="rotZ" class="slider" min="0" max="360" value="0">
                    </div>

                    <button class="reset-rotation-btn" onclick="resetRotation()">
                        ğŸ”„ ××¤×¡ ×¡×™×‘×•×‘
                    </button>
                </div>

                <button class="close-fullscreen" onclick="toggleFullscreen()">âœ• ×¡×’×•×¨ ××¡×š ××œ×</button>
                
                <div class="fullscreen-controls" id="fullscreenControls">
                    <div class="control-group">
                        <label>
                            <span class="value-display" id="cutYValueFS">×—×™×ª×•×š ×× ×›×™: 0%</span>
                            ×—×™×ª×•×š ××œ××¢×œ×” ×œ××˜×”
                        </label>
                        <input type="range" id="cutYFS" class="slider" min="0" max="100" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="cutXValueFS">×—×™×ª×•×š ×¨×•×—×‘: 0%</span>
                            ×—×™×ª×•×š ××©×××œ ×œ×™××™×Ÿ
                        </label>
                        <input type="range" id="cutXFS" class="slider" min="0" max="100" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="cutZValueFS">×—×™×ª×•×š ×¢×•××§: 0%</span>
                            ×—×™×ª×•×š ×××—×•×¨×” ×œ×§×“×™××”
                        </label>
                        <input type="range" id="cutZFS" class="slider" min="0" max="100" value="0">
                    </div>

                    <div class="section-divider">×¡×™×‘×•×‘ ×”××•×“×œ</div>
                    
                    <div class="control-group">
                        <label>
                            <span class="value-display" id="rotXValueFS">×¡×™×‘×•×‘ X: 0Â°</span>
                            ×¡×™×‘×•×‘ ×¡×‘×™×‘ ×¦×™×¨ X
                        </label>
                        <input type="range" id="rotXFS" class="slider" min="0" max="360" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="rotYValueFS">×¡×™×‘×•×‘ Y: 0Â°</span>
                            ×¡×™×‘×•×‘ ×¡×‘×™×‘ ×¦×™×¨ Y
                        </label>
                        <input type="range" id="rotYFS" class="slider" min="0" max="360" value="0">
                    </div>

                    <div class="control-group">
                        <label>
                            <span class="value-display" id="rotZValueFS">×¡×™×‘×•×‘ Z: 0Â°</span>
                            ×¡×™×‘×•×‘ ×¡×‘×™×‘ ×¦×™×¨ Z
                        </label>
                        <input type="range" id="rotZFS" class="slider" min="0" max="360" value="0">
                    </div>

                    <button class="reset-rotation-btn" onclick="resetRotation()">
                        ğŸ”„ ××¤×¡ ×¡×™×‘×•×‘
                    </button>
                </div>

                <div class="viewer viewer-flex">
                    <div id="canvas-container">
                        <div class="instruction">
                            <div class="instruction-icon">ğŸ›ï¸</div>
                            <div>×”×¢×œ×” ××•×“×œ×™× ×ª×œ×ª-×××“×™×™× ×›×“×™ ×œ×”×ª×—×™×œ</div>
                            <div class="instruction-hint">
                                ×ª×•×›×œ ×œ×”×¢×œ×•×ª ××¡×¤×¨ ××•×“×œ×™× ×•×œ×¨××•×ª ××ª ×”×©×›×‘×•×ª ××—×ª ×¢×œ ×”×©× ×™×™×”<br>
                                <strong>×ª××™×›×” ××œ××” ×‘: OBJ, STL, GLB, GLTF</strong><br>
                                <strong>×™×™×©×•×¨ ×’××™×©: ×‘×—×¨ ×›××” × ×§×•×“×•×ª ×©×ª×¨×¦×”!</strong>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let models = [];
        let modelCounter = 0;
        let globalBoundingBox = null;
        let gridHelper = null;
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { horizontal: 45, vertical: 30 };
        let cameraDistance = 8;

        // ×§×‘×•×¦×ª ××•×“×œ×™× ×©× ×™×ª×Ÿ ×œ×¡×•×‘×‘ (×œ×œ× ×”×¨×¦×¤×”)
        let modelsGroup = new THREE.Group();

        // ××©×ª× ×™× ×œ××“×™×“×ª ××¨×—×§
        let measureState = {
            active: false,
            points: [],
            markers: [],
            line: null
        };

        // ××©×ª× ×™× ×œ×™×™×©×•×¨ - ×’×¨×¡×” ×’××™×©×”
        let alignState = {
            active: false,
            selectingModel: null,
            model1: null,
            model2: null,
            points1: [],
            points2: [],
            minPoints: 2
        };

        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // ××™×¤×•×™ ×¦×‘×¢×™× ×œ×©××•×ª ×‘×¢×‘×¨×™×ª
        const colorNames = {
            0xFF6B6B: { name: '××“×•×', hex: '#FF6B6B' },
            0x4ECDC4: { name: '×˜×•×¨×§×™×–', hex: '#4ECDC4' },
            0x45B7D1: { name: '×›×—×•×œ', hex: '#45B7D1' },
            0xFFA07A: { name: '×›×ª×•×', hex: '#FFA07A' },
            0x98D8C8: { name: '×™×¨×•×§', hex: '#98D8C8' }
        };

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const instruction = container.querySelector('.instruction');
            if (instruction) instruction.remove();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            updateCameraPosition();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // ×”×•×¡×£ ××ª ×§×‘×•×¦×ª ×”××•×“×œ×™× ×œ×¡×¦× ×”
            scene.add(modelsGroup);

            // ××•×¨
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);

            // ×¨×¦×¤×”
            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // ××™×¨×•×¢×™ ×¢×›×‘×¨
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onMouseWheel);
            renderer.domElement.addEventListener('click', onCanvasClick);

            window.addEventListener('resize', onWindowResize);

            animate();
            setupSliderListeners();
        }

        function setupSliderListeners() {
            // ×—×™×ª×•×š
            ['cutY', 'cutX', 'cutZ'].forEach(id => {
                const slider = document.getElementById(id);
                const sliderFS = document.getElementById(id + 'FS');
                
                slider.addEventListener('input', (e) => {
                    sliderFS.value = e.target.value;
                    updateClipping();
                    updateValueDisplay(id, e.target.value);
                });
                
                sliderFS.addEventListener('input', (e) => {
                    slider.value = e.target.value;
                    updateClipping();
                    updateValueDisplay(id + 'FS', e.target.value);
                });
            });

            // ×¡×™×‘×•×‘
            ['rotX', 'rotY', 'rotZ'].forEach(id => {
                const slider = document.getElementById(id);
                const sliderFS = document.getElementById(id + 'FS');
                
                slider.addEventListener('input', (e) => {
                    sliderFS.value = e.target.value;
                    updateRotation();
                    updateRotationDisplay(id, e.target.value);
                });
                
                sliderFS.addEventListener('input', (e) => {
                    slider.value = e.target.value;
                    updateRotation();
                    updateRotationDisplay(id + 'FS', e.target.value);
                });
            });
        }

        function updateRotation() {
            const rotX = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
            const rotY = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
            const rotZ = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;

            modelsGroup.rotation.set(rotX, rotY, rotZ);
        }

        function resetRotation() {
            ['rotX', 'rotY', 'rotZ'].forEach(id => {
                document.getElementById(id).value = 0;
                document.getElementById(id + 'FS').value = 0;
                updateRotationDisplay(id, 0);
            });
            modelsGroup.rotation.set(0, 0, 0);
        }

        function updateRotationDisplay(id, value) {
            const displayId = id.replace('FS', '') + 'Value' + (id.includes('FS') ? 'FS' : '');
            const display = document.getElementById(displayId);
            if (display) {
                const axis = id.includes('rotX') ? 'X' : id.includes('rotY') ? 'Y' : 'Z';
                display.textContent = `×¡×™×‘×•×‘ ${axis}: ${value}Â°`;
            }
        }

        function updateValueDisplay(id, value) {
            const displayId = id.replace('FS', '') + 'Value' + (id.includes('FS') ? 'FS' : '');
            const display = document.getElementById(displayId);
            if (display) {
                const label = id.includes('cutY') ? '×—×™×ª×•×š ×× ×›×™' :
                             id.includes('cutX') ? '×—×™×ª×•×š ×¨×•×—×‘' : '×—×™×ª×•×š ×¢×•××§';
                display.textContent = `${label}: ${value}%`;
            }
        }

        function updateCameraPosition() {
            const horizontalRad = cameraRotation.horizontal * Math.PI / 180;
            const verticalRad = cameraRotation.vertical * Math.PI / 180;
            
            camera.position.x = cameraDistance * Math.cos(verticalRad) * Math.cos(horizontalRad);
            camera.position.y = cameraDistance * Math.sin(verticalRad);
            camera.position.z = cameraDistance * Math.cos(verticalRad) * Math.sin(horizontalRad);
            
            camera.lookAt(0, 0, 0);
        }

        function onMouseDown(event) {
            if (alignState.active || measureState.active) return;
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseMove(event) {
            if (!isDragging || alignState.active || measureState.active) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            cameraRotation.horizontal += deltaX * 0.3;
            cameraRotation.vertical = Math.max(-89, Math.min(89, cameraRotation.vertical - deltaY * 0.3));

            updateCameraPosition();
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onMouseWheel(event) {
            event.preventDefault();
            cameraDistance += event.deltaY * 0.01;
            cameraDistance = Math.max(2, Math.min(50, cameraDistance));
            updateCameraPosition();
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // ==================== ××“×™×“×ª ××¨×—×§ ====================
        
        function toggleMeasureMode() {
            measureState.active = !measureState.active;
            const btn = document.getElementById('measureBtn');
            const info = document.getElementById('measureInfo');
            
            if (measureState.active) {
                btn.textContent = 'âŒ ×‘×˜×œ ××“×™×“×”';
                btn.classList.add('active');
                info.classList.remove('hidden');
                document.getElementById('measureStatus').textContent = '×‘×—×¨ × ×§×•×“×” ×¨××©×•× ×”...';
                document.getElementById('measureDistance').textContent = '';
                clearMeasurement();
            } else {
                btn.textContent = 'ğŸ¯ ×”×ª×—×œ ××“×™×“×”';
                btn.classList.remove('active');
                info.classList.add('hidden');
                clearMeasurement();
            }
        }

        function clearMeasurement() {
            measureState.points = [];
            measureState.markers.forEach(marker => scene.remove(marker));
            measureState.markers = [];
            if (measureState.line) {
                scene.remove(measureState.line);
                measureState.line = null;
            }
        }

        function addMeasurePoint(point) {
            // ×”×•×¡×£ ×¡××Ÿ
            const markerGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ 
                color: measureState.points.length === 0 ? 0x00ff00 : 0xff0000 
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(point);
            scene.add(marker);
            measureState.markers.push(marker);
            measureState.points.push(point);

            if (measureState.points.length === 1) {
                document.getElementById('measureStatus').textContent = '×‘×—×¨ × ×§×•×“×” ×©× ×™×™×”...';
            } else if (measureState.points.length === 2) {
                // ×—×©×‘ ××¨×—×§
                const distance = measureState.points[0].distanceTo(measureState.points[1]);
                
                // ×¦×•×¨ ×§×•
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(measureState.points);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 2 });
                measureState.line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(measureState.line);

                // ×”×¦×’ ××¨×—×§
                document.getElementById('measureStatus').textContent = '××“×™×“×” ×”×•×©×œ××”!';
                document.getElementById('measureDistance').textContent = `××¨×—×§: ${distance.toFixed(3)} ×™×—×™×“×•×ª`;
                
                // ××¤×©×¨ ××“×™×“×” ×—×“×©×”
                setTimeout(() => {
                    if (measureState.active) {
                        clearMeasurement();
                        document.getElementById('measureStatus').textContent = '×‘×—×¨ × ×§×•×“×” ×¨××©×•× ×” ×œ××“×™×“×” ×—×“×©×”...';
                        document.getElementById('measureDistance').textContent = '';
                    }
                }, 3000);
            }
        }

        function onCanvasClick(event) {
            if (!measureState.active && !alignState.active) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // ×‘×“×•×§ ×—×™×ª×•×š ×¢× ×›×œ ×”××•×“×œ×™×
            const intersectObjects = [];
            models.forEach(model => {
                if (model.mesh && model.mesh.visible) {
                    intersectObjects.push(model.mesh);
                }
            });

            const intersects = raycaster.intersectObjects(intersectObjects, true);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                
                if (measureState.active) {
                    addMeasurePoint(point);
                } else if (alignState.active && alignState.selectingModel) {
                    addAlignmentPoint(point);
                }
            }
        }

        // ==================== ×”×¢×œ××ª ×§×‘×¦×™× ====================

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            const loadingMessage = document.getElementById('loadingMessage');
            loadingMessage.classList.remove('hidden');
            loadingMessage.textContent = `×˜×•×¢×Ÿ ${files.length} ×§×‘×¦×™×...`;

            Array.from(files).forEach((file, index) => {
                setTimeout(() => {
                    loadModel(file);
                    if (index === files.length - 1) {
                        setTimeout(() => {
                            loadingMessage.classList.add('hidden');
                        }, 500);
                    }
                }, index * 100);
            });

            event.target.value = '';
        }

        function loadModel(file) {
            const reader = new FileReader();
            const extension = file.name.split('.').pop().toLowerCase();

            reader.onload = function(e) {
                try {
                    let geometry;
                    
                    if (extension === 'obj') {
                        geometry = parseOBJ(e.target.result);
                    } else if (extension === 'stl') {
                        geometry = parseSTL(e.target.result);
                    } else if (extension === 'glb' || extension === 'gltf') {
                        parseGLTF(e.target.result, extension === 'glb', file.name);
                        return;
                    }

                    if (geometry) {
                        addModelToScene(geometry, file.name);
                    }
                } catch (error) {
                    console.error('Error loading model:', error);
                    alert('×©×’×™××” ×‘×˜×¢×™× ×ª ×”×§×•×‘×¥: ' + file.name);
                }
            };

            if (extension === 'glb') {
                reader.readAsArrayBuffer(file);
            } else {
                reader.readAsText(file);
            }
        }

        function parseOBJ(data) {
            const vertices = [];
            const faces = [];
            
            const lines = data.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                if (line.startsWith('v ')) {
                    const parts = line.split(/\s+/);
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                } else if (line.startsWith('f ')) {
                    const parts = line.split(/\s+/);
                    const indices = parts.slice(1).map(p => {
                        const idx = p.split('/')[0];
                        return parseInt(idx) - 1;
                    });
                    
                    for (let i = 1; i < indices.length - 1; i++) {
                        faces.push(indices[0], indices[i], indices[i + 1]);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(faces.length * 3);
            
            for (let i = 0; i < faces.length; i++) {
                const vertexIndex = faces[i];
                positions[i * 3] = vertices[vertexIndex * 3];
                positions[i * 3 + 1] = vertices[vertexIndex * 3 + 1];
                positions[i * 3 + 2] = vertices[vertexIndex * 3 + 2];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function parseSTL(data) {
            const isBinary = !data.match(/^solid/i);
            
            if (isBinary) {
                return parseSTLBinary(data);
            } else {
                return parseSTLASCII(data);
            }
        }

        function parseSTLASCII(data) {
            const vertices = [];
            const lines = data.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                if (line.startsWith('vertex')) {
                    const parts = line.split(/\s+/);
                    vertices.push(
                        parseFloat(parts[1]),
                        parseFloat(parts[2]),
                        parseFloat(parts[3])
                    );
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function parseSTLBinary(data) {
            const reader = new DataView(data);
            const faces = reader.getUint32(80, true);
            const vertices = [];

            for (let i = 0; i < faces; i++) {
                const offset = 84 + i * 50;
                
                for (let j = 0; j < 3; j++) {
                    vertices.push(
                        reader.getFloat32(offset + 12 + j * 12, true),
                        reader.getFloat32(offset + 16 + j * 12, true),
                        reader.getFloat32(offset + 20 + j * 12, true)
                    );
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        function parseGLTF(data, isBinary, filename) {
            let json, bufferData;

            if (isBinary) {
                const header = new DataView(data, 0, 12);
                const magic = header.getUint32(0, true);
                if (magic !== 0x46546C67) {
                    throw new Error('Not a valid GLB file');
                }

                const jsonChunkLength = header.getUint32(12, true);
                const jsonChunkData = new Uint8Array(data, 20, jsonChunkLength);
                const jsonString = new TextDecoder().decode(jsonChunkData);
                json = JSON.parse(jsonString);

                const bufferChunkStart = 20 + jsonChunkLength + 8;
                bufferData = data.slice(bufferChunkStart);
            } else {
                json = JSON.parse(data);
            }

            const meshes = json.meshes || [];
            if (meshes.length === 0) {
                throw new Error('No meshes found in GLTF file');
            }

            meshes.forEach((mesh, meshIndex) => {
                mesh.primitives.forEach((primitive, primIndex) => {
                    const geometry = extractGeometryFromGLTF(json, primitive, bufferData);
                    if (geometry) {
                        const modelName = `${filename}_mesh${meshIndex}_prim${primIndex}`;
                        addModelToScene(geometry, modelName);
                    }
                });
            });
        }

        function extractGeometryFromGLTF(gltf, primitive, bufferData) {
            const positionAccessorIndex = primitive.attributes.POSITION;
            if (positionAccessorIndex === undefined) return null;

            const accessor = gltf.accessors[positionAccessorIndex];
            const bufferView = gltf.bufferViews[accessor.bufferView];
            
            let positions;
            if (bufferData) {
                const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
                const length = accessor.count * 3;
                positions = new Float32Array(bufferData, byteOffset, length);
            } else {
                const buffer = gltf.buffers[bufferView.buffer];
                const base64Data = buffer.uri.split(',')[1];
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
                const length = accessor.count * 3;
                positions = new Float32Array(bytes.buffer, byteOffset, length);
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            if (primitive.indices !== undefined) {
                const indexAccessor = gltf.accessors[primitive.indices];
                const indexBufferView = gltf.bufferViews[indexAccessor.bufferView];
                
                let indices;
                if (bufferData) {
                    const byteOffset = (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0);
                    const componentType = indexAccessor.componentType;
                    
                    if (componentType === 5123) {
                        indices = new Uint16Array(bufferData, byteOffset, indexAccessor.count);
                    } else if (componentType === 5125) {
                        indices = new Uint32Array(bufferData, byteOffset, indexAccessor.count);
                    }
                } else {
                    const buffer = gltf.buffers[indexBufferView.buffer];
                    const base64Data = buffer.uri.split(',')[1];
                    const binaryString = atob(base64Data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const byteOffset = (indexBufferView.byteOffset || 0) + (indexAccessor.byteOffset || 0);
                    const componentType = indexAccessor.componentType;
                    
                    if (componentType === 5123) {
                        indices = new Uint16Array(bytes.buffer, byteOffset, indexAccessor.count);
                    } else if (componentType === 5125) {
                        indices = new Uint32Array(bytes.buffer, byteOffset, indexAccessor.count);
                    }
                }
                
                if (indices) {
                    geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                }
            }

            geometry.computeVertexNormals();
            return geometry;
        }

        function addModelToScene(geometry, filename) {
            if (!scene) initThreeJS();

            const colors = [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0xFFA07A, 0x98D8C8];
            const color = colors[modelCounter % colors.length];

            const material = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 30,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });

            const mesh = new THREE.Mesh(geometry, material);
            modelsGroup.add(mesh);

            const model = {
                id: modelCounter++,
                name: filename,
                mesh: mesh,
                originalGeometry: geometry.clone(),
                color: color,
                visible: true,
                wireframe: false
            };

            models.push(model);
            updateGlobalBoundingBox();
            updateModelList();
            updateDownloadSection();

            if (models.length === 1) {
                fitCameraToModels();
            }
        }

        function updateGlobalBoundingBox() {
            globalBoundingBox = new THREE.Box3();
            
            models.forEach(model => {
                if (model.mesh && model.visible) {
                    const box = new THREE.Box3().setFromObject(model.mesh);
                    globalBoundingBox.union(box);
                }
            });

            if (gridHelper) {
                const size = globalBoundingBox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const gridSize = Math.ceil(maxDim * 1.5);
                
                scene.remove(gridHelper);
                gridHelper = new THREE.GridHelper(gridSize, Math.min(gridSize, 40), 0x444444, 0x222222);
                const center = globalBoundingBox.getCenter(new THREE.Vector3());
                gridHelper.position.y = globalBoundingBox.min.y;
                scene.add(gridHelper);
            }
        }

        function fitCameraToModels() {
            if (!globalBoundingBox) return;

            const size = globalBoundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            cameraDistance = maxDim * 2;
            updateCameraPosition();
        }

        function updateClipping() {
            if (!globalBoundingBox) return;

            const cutYPercent = parseFloat(document.getElementById('cutY').value);
            const cutXPercent = parseFloat(document.getElementById('cutX').value);
            const cutZPercent = parseFloat(document.getElementById('cutZ').value);

            const size = globalBoundingBox.getSize(new THREE.Vector3());

            models.forEach(model => {
                if (!model.mesh) return;

                const geometry = model.originalGeometry.clone();
                const positions = geometry.attributes.position.array;
                const newPositions = [];

                const cutYThreshold = globalBoundingBox.max.y - (size.y * cutYPercent / 100);
                const cutXThreshold = globalBoundingBox.min.x + (size.x * cutXPercent / 100);
                const cutZThreshold = globalBoundingBox.min.z + (size.z * cutZPercent / 100);

                for (let i = 0; i < positions.length; i += 9) {
                    const y1 = positions[i + 1];
                    const y2 = positions[i + 4];
                    const y3 = positions[i + 7];

                    const x1 = positions[i];
                    const x2 = positions[i + 3];
                    const x3 = positions[i + 6];

                    const z1 = positions[i + 2];
                    const z2 = positions[i + 5];
                    const z3 = positions[i + 8];

                    if (y1 <= cutYThreshold && y2 <= cutYThreshold && y3 <= cutYThreshold &&
                        x1 >= cutXThreshold && x2 >= cutXThreshold && x3 >= cutXThreshold &&
                        z1 >= cutZThreshold && z2 >= cutZThreshold && z3 >= cutZThreshold) {
                        
                        for (let j = 0; j < 9; j++) {
                            newPositions.push(positions[i + j]);
                        }
                    }
                }

                const newGeometry = new THREE.BufferGeometry();
                newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                newGeometry.computeVertexNormals();

                model.mesh.geometry.dispose();
                model.mesh.geometry = newGeometry;
            });
        }

        function updateModelList() {
            const modelList = document.getElementById('modelList');
            modelList.innerHTML = '';

            models.forEach(model => {
                const item = document.createElement('div');
                item.className = 'model-item';
                
                const colorInfo = colorNames[model.color];
                
                item.innerHTML = `
                    <div class="model-item-header">
                        <span class="model-color-indicator" style="background-color: ${colorInfo.hex}"></span>
                        <span class="model-name">${model.name}</span>
                    </div>
                    <div class="model-item-color">
                        ×¦×‘×¢: ${colorInfo.name}
                    </div>
                    <div class="model-item-controls">
                        <button onclick="toggleModelVisibility(${model.id})" class="model-btn" title="×”×¦×’/×”×¡×ª×¨">
                            ${model.visible ? 'ğŸ‘ï¸' : 'ğŸš«'}
                        </button>
                        <button onclick="toggleWireframe(${model.id})" class="model-btn" title="××¡×’×¨×ª ×ª×™×œ">
                            ğŸ”²
                        </button>
                        <button onclick="deleteModel(${model.id})" class="model-btn delete-btn" title="××—×§">
                            ğŸ—‘ï¸
                        </button>
                        <button onclick="startAlignment(${model.id})" class="model-btn align-btn" 
                                ${models.length < 2 ? 'disabled' : ''} title="×™×™×©×¨ ×œ××•×“×œ ××—×¨">
                            ğŸ“
                        </button>
                    </div>
                `;
                
                modelList.appendChild(item);
            });
        }

        function toggleModelVisibility(id) {
            const model = models.find(m => m.id === id);
            if (model && model.mesh) {
                model.visible = !model.visible;
                model.mesh.visible = model.visible;
                updateModelList();
                updateGlobalBoundingBox();
            }
        }

        function toggleWireframe(id) {
            const model = models.find(m => m.id === id);
            if (model && model.mesh) {
                model.wireframe = !model.wireframe;
                model.mesh.material.wireframe = model.wireframe;
            }
        }

        function deleteModel(id) {
            const modelIndex = models.findIndex(m => m.id === id);
            if (modelIndex !== -1) {
                const model = models[modelIndex];
                if (model.mesh) {
                    modelsGroup.remove(model.mesh);
                    model.mesh.geometry.dispose();
                    model.mesh.material.dispose();
                }
                models.splice(modelIndex, 1);
                updateModelList();
                updateGlobalBoundingBox();
                updateDownloadSection();
            }
        }

        function updateDownloadSection() {
            const downloadSection = document.getElementById('downloadSection');
            if (models.length > 0) {
                downloadSection.classList.remove('hidden');
            } else {
                downloadSection.classList.add('hidden');
            }
        }

        function toggleFullscreen() {
            const container = document.querySelector('.container');
            const viewer = document.querySelector('.viewer');
            const controls = document.getElementById('fullscreenControls');
            
            container.classList.toggle('fullscreen-mode');
            viewer.classList.toggle('fullscreen-viewer');
            controls.classList.toggle('visible');
            
            setTimeout(() => onWindowResize(), 100);
        }

        // ==================== ×™×™×©×•×¨ ××•×“×œ×™× ====================

        function startAlignment(modelId) {
            if (models.length < 2) {
                alert('× ×“×¨×©×™× ×œ×¤×—×•×ª 2 ××•×“×œ×™× ×œ×™×™×©×•×¨');
                return;
            }

            alignState.active = true;
            alignState.selectingModel = 1;
            alignState.model1 = models.find(m => m.id === modelId);
            alignState.model2 = null;
            alignState.points1 = [];
            alignState.points2 = [];

            document.getElementById('alignSection').classList.remove('hidden');
            updateAlignmentUI();
        }

        function addAlignmentPoint(point) {
            if (alignState.selectingModel === 1) {
                alignState.points1.push(point.clone());
                
                const marker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                marker.position.copy(point);
                scene.add(marker);

                if (!alignState.markers1) alignState.markers1 = [];
                alignState.markers1.push(marker);
            } else if (alignState.selectingModel === 2) {
                alignState.points2.push(point.clone());
                
                const marker = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                marker.position.copy(point);
                scene.add(marker);

                if (!alignState.markers2) alignState.markers2 = [];
                alignState.markers2.push(marker);
            }

            updateAlignmentUI();
        }

        function finishCurrentModel() {
            if (alignState.selectingModel === 1) {
                if (alignState.points1.length < alignState.minPoints) {
                    alert(`× ×“×¨×©×•×ª ×œ×¤×—×•×ª ${alignState.minPoints} × ×§×•×“×•×ª`);
                    return;
                }

                const otherModels = models.filter(m => m.id !== alignState.model1.id);
                if (otherModels.length === 0) return;

                alignState.model2 = otherModels[0];
                alignState.selectingModel = 2;
                updateAlignmentUI();
            }
        }

        function undoLastPoint() {
            if (alignState.selectingModel === 1 && alignState.points1.length > 0) {
                alignState.points1.pop();
                const marker = alignState.markers1.pop();
                scene.remove(marker);
            } else if (alignState.selectingModel === 2 && alignState.points2.length > 0) {
                alignState.points2.pop();
                const marker = alignState.markers2.pop();
                scene.remove(marker);
            }
            updateAlignmentUI();
        }

        function updateAlignmentUI() {
            const status = document.getElementById('alignStatus');
            const counter = document.getElementById('pointCounter');
            const finishBtn = document.getElementById('finishModelBtn');
            const undoBtn = document.getElementById('undoPointBtn');
            const executeBtn = document.getElementById('executeAlignBtn');

            const count1 = alignState.points1.length;
            const count2 = alignState.points2.length;

            counter.textContent = `××•×“×œ 1: ${count1} × ×§×•×“×•×ª | ××•×“×œ 2: ${count2} × ×§×•×“×•×ª`;

            if (alignState.selectingModel === 1) {
                status.textContent = `×‘×—×¨ × ×§×•×“×•×ª ×¢×œ: ${alignState.model1.name}`;
                finishBtn.classList.toggle('hidden', count1 < alignState.minPoints);
                undoBtn.classList.toggle('hidden', count1 === 0);
                executeBtn.disabled = true;
            } else if (alignState.selectingModel === 2) {
                status.textContent = `×‘×—×¨ × ×§×•×“×•×ª ×¢×œ: ${alignState.model2.name}`;
                finishBtn.classList.add('hidden');
                undoBtn.classList.toggle('hidden', count2 === 0);
                executeBtn.disabled = count2 < alignState.minPoints || count2 !== count1;
            }
        }

        function executeAlignment() {
            if (alignState.points1.length !== alignState.points2.length ||
                alignState.points1.length < alignState.minPoints) {
                alert('××¡×¤×¨ ×”× ×§×•×“×•×ª ×œ× ×ª×•×× ××• ×œ× ××¡×¤×™×§ × ×§×•×“×•×ª');
                return;
            }

            const centroid1 = new THREE.Vector3();
            const centroid2 = new THREE.Vector3();

            alignState.points1.forEach(p => centroid1.add(p));
            alignState.points2.forEach(p => centroid2.add(p));

            centroid1.divideScalar(alignState.points1.length);
            centroid2.divideScalar(alignState.points2.length);

            const translation = new THREE.Vector3().subVectors(centroid2, centroid1);
            alignState.model1.mesh.position.add(translation);

            alert('×™×™×©×•×¨ ×‘×•×¦×¢ ×‘×”×¦×œ×—×”!');
            cancelAlignment();
        }

        function cancelAlignment() {
            alignState.active = false;
            alignState.selectingModel = null;
            alignState.points1 = [];
            alignState.points2 = [];

            if (alignState.markers1) {
                alignState.markers1.forEach(m => scene.remove(m));
                alignState.markers1 = [];
            }
            if (alignState.markers2) {
                alignState.markers2.forEach(m => scene.remove(m));
                alignState.markers2 = [];
            }

            document.getElementById('alignSection').classList.add('hidden');
        }

        // ==================== ×™×™×¦×•× ====================

        function getCombinedGeometry() {
            const combinedPositions = [];
            const combinedNormals = [];

            models.forEach(model => {
                if (!model.mesh || !model.visible) return;

                const geometry = model.mesh.geometry;
                const positions = geometry.attributes.position.array;
                const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;

                const matrix = model.mesh.matrixWorld;

                for (let i = 0; i < positions.length; i += 3) {
                    const vertex = new THREE.Vector3(positions[i], positions[i + 1], positions[i + 2]);
                    vertex.applyMatrix4(matrix);
                    combinedPositions.push(vertex.x, vertex.y, vertex.z);

                    if (normals) {
                        const normal = new THREE.Vector3(normals[i], normals[i + 1], normals[i + 2]);
                        normal.transformDirection(matrix);
                        combinedNormals.push(normal.x, normal.y, normal.z);
                    }
                }
            });

            if (combinedPositions.length === 0) return null;

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(combinedPositions, 3));
            if (combinedNormals.length > 0) {
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(combinedNormals, 3));
            } else {
                geometry.computeVertexNormals();
            }

            return geometry;
        }

        function exportToSTL(geometry) {
            const positions = geometry.attributes.position.array;
            const normals = geometry.attributes.normal.array;

            let stlString = 'solid exported\n';

            for (let i = 0; i < positions.length; i += 9) {
                const nx = normals[i];
                const ny = normals[i + 1];
                const nz = normals[i + 2];

                stlString += `  facet normal ${nx} ${ny} ${nz}\n`;
                stlString += '    outer loop\n';

                for (let j = 0; j < 3; j++) {
                    const idx = i + j * 3;
                    stlString += `      vertex ${positions[idx]} ${positions[idx + 1]} ${positions[idx + 2]}\n`;
                }

                stlString += '    endloop\n';
                stlString += '  endfacet\n';
            }

            stlString += 'endsolid exported\n';

            return new Blob([stlString], { type: 'text/plain' });
        }

        function exportToOBJ(geometry) {
            const positions = geometry.attributes.position.array;
            const normals = geometry.attributes.normal ? geometry.attributes.normal.array : null;

            let objString = '# Exported OBJ\n';

            for (let i = 0; i < positions.length; i += 3) {
                objString += `v ${positions[i]} ${positions[i + 1]} ${positions[i + 2]}\n`;
            }

            if (normals) {
                for (let i = 0; i < normals.length; i += 3) {
                    objString += `vn ${normals[i]} ${normals[i + 1]} ${normals[i + 2]}\n`;
                }
            }

            const vertexCount = positions.length / 3;
            for (let i = 1; i <= vertexCount; i += 3) {
                if (normals) {
                    objString += `f ${i}//${i} ${i + 1}//${i + 1} ${i + 2}//${i + 2}\n`;
                } else {
                    objString += `f ${i} ${i + 1} ${i + 2}\n`;
                }
            }

            return new Blob([objString], { type: 'text/plain' });
        }

        function exportToGLTF(geometry, binary) {
            const positionBuffer = geometry.attributes.position.array;
            const normalBuffer = geometry.attributes.normal ? geometry.attributes.normal.array : null;
            const indexBuffer = geometry.index ? geometry.index.array : null;

            let minPos = [Infinity, Infinity, Infinity];
            let maxPos = [-Infinity, -Infinity, -Infinity];
            
            for (let i = 0; i < positionBuffer.length; i += 3) {
                minPos[0] = Math.min(minPos[0], positionBuffer[i]);
                minPos[1] = Math.min(minPos[1], positionBuffer[i + 1]);
                minPos[2] = Math.min(minPos[2], positionBuffer[i + 2]);
                maxPos[0] = Math.max(maxPos[0], positionBuffer[i]);
                maxPos[1] = Math.max(maxPos[1], positionBuffer[i + 1]);
                maxPos[2] = Math.max(maxPos[2], positionBuffer[i + 2]);
            }

            if (binary) {
                return exportToGLB(positionBuffer, normalBuffer, indexBuffer, minPos, maxPos);
            } else {
                return exportToGLTFJSON(positionBuffer, normalBuffer, indexBuffer, minPos, maxPos);
            }
        }

        function exportToGLB(positionBuffer, normalBuffer, indexBuffer, minPos, maxPos) {
            const positionByteLength = positionBuffer.byteLength;
            const normalByteLength = normalBuffer ? normalBuffer.byteLength : 0;
            const indexByteLength = indexBuffer ? indexBuffer.byteLength : 0;

            let totalLength = positionByteLength + normalByteLength + indexByteLength;
            const padding = (4 - (totalLength % 4)) % 4;
            totalLength += padding;

            const combinedBuffer = new Uint8Array(totalLength);
            let offset = 0;

            combinedBuffer.set(new Uint8Array(positionBuffer.buffer), offset);
            const positionOffset = offset;
            offset += positionByteLength;

            let normalOffset = 0;
            if (normalBuffer) {
                combinedBuffer.set(new Uint8Array(normalBuffer.buffer), offset);
                normalOffset = offset;
                offset += normalByteLength;
            }

            let indexOffset = 0;
            let indexComponentType = 0;
            if (indexBuffer) {
                combinedBuffer.set(new Uint8Array(indexBuffer.buffer), offset);
                indexOffset = offset;
                indexComponentType = indexBuffer instanceof Uint16Array ? 5123 : 5125;
            }

            const bufferViews = [];
            const accessors = [];

            bufferViews.push({
                buffer: 0,
                byteOffset: positionOffset,
                byteLength: positionByteLength,
                target: 34962
            });
            accessors.push({
                bufferView: 0,
                byteOffset: 0,
                componentType: 5126,
                count: positionBuffer.length / 3,
                type: 'VEC3',
                min: minPos,
                max: maxPos
            });

            let normalAccessorIndex = -1;
            if (normalBuffer) {
                bufferViews.push({
                    buffer: 0,
                    byteOffset: normalOffset,
                    byteLength: normalByteLength,
                    target: 34962
                });
                normalAccessorIndex = accessors.length;
                accessors.push({
                    bufferView: bufferViews.length - 1,
                    byteOffset: 0,
                    componentType: 5126,
                    count: normalBuffer.length / 3,
                    type: 'VEC3'
                });
            }

            let indexAccessorIndex = -1;
            if (indexBuffer) {
                bufferViews.push({
                    buffer: 0,
                    byteOffset: indexOffset,
                    byteLength: indexByteLength,
                    target: 34963
                });
                indexAccessorIndex = accessors.length;
                accessors.push({
                    bufferView: bufferViews.length - 1,
                    byteOffset: 0,
                    componentType: indexComponentType,
                    count: indexBuffer.length,
                    type: 'SCALAR'
                });
            }

            const primitive = {
                attributes: { POSITION: 0 },
                mode: 4
            };
            if (normalAccessorIndex >= 0) {
                primitive.attributes.NORMAL = normalAccessorIndex;
            }
            if (indexAccessorIndex >= 0) {
                primitive.indices = indexAccessorIndex;
            }

            const gltf = {
                asset: { version: '2.0', generator: 'Archaeological Site Viewer' },
                scene: 0,
                scenes: [{ nodes: [0] }],
                nodes: [{ mesh: 0 }],
                meshes: [{ primitives: [primitive] }],
                accessors: accessors,
                bufferViews: bufferViews,
                buffers: [{ byteLength: totalLength }]
            };

            const jsonStr = JSON.stringify(gltf);
            const jsonBuffer = new TextEncoder().encode(jsonStr);
            const jsonPadding = (4 - (jsonBuffer.length % 4)) % 4;
            const jsonChunkLength = jsonBuffer.length + jsonPadding;

            const binPadding = (4 - (combinedBuffer.length % 4)) % 4;
            const binChunkLength = combinedBuffer.length + binPadding;

            const totalSize = 12 + 8 + jsonChunkLength + 8 + binChunkLength;
            const glbBuffer = new ArrayBuffer(totalSize);
            const view = new DataView(glbBuffer);

            let glbOffset = 0;
            view.setUint32(glbOffset, 0x46546C67, true);
            glbOffset += 4;
            view.setUint32(glbOffset, 2, true);
            glbOffset += 4;
            view.setUint32(glbOffset, totalSize, true);
            glbOffset += 4;

            view.setUint32(glbOffset, jsonChunkLength, true);
            glbOffset += 4;
            view.setUint32(glbOffset, 0x4E4F534A, true);
            glbOffset += 4;
            new Uint8Array(glbBuffer, glbOffset).set(jsonBuffer);
            glbOffset += jsonBuffer.length;
            for (let i = 0; i < jsonPadding; i++) {
                view.setUint8(glbOffset++, 0x20);
            }

            view.setUint32(glbOffset, binChunkLength, true);
            glbOffset += 4;
            view.setUint32(glbOffset, 0x004E4942, true);
            glbOffset += 4;
            new Uint8Array(glbBuffer, glbOffset).set(combinedBuffer);
            glbOffset += combinedBuffer.length;
            for (let i = 0; i < binPadding; i++) {
                view.setUint8(glbOffset++, 0);
            }

            return new Blob([glbBuffer], { type: 'model/gltf-binary' });
        }

        function exportToGLTFJSON(positionBuffer, normalBuffer, indexBuffer, minPos, maxPos) {
            const positionByteLength = positionBuffer.byteLength;
            const normalByteLength = normalBuffer ? normalBuffer.byteLength : 0;
            const indexByteLength = indexBuffer ? indexBuffer.byteLength : 0;

            let totalLength = positionByteLength + normalByteLength + indexByteLength;
            const padding = (4 - (totalLength % 4)) % 4;
            totalLength += padding;

            const combinedBuffer = new Uint8Array(totalLength);
            let offset = 0;

            combinedBuffer.set(new Uint8Array(positionBuffer.buffer), offset);
            const positionOffset = offset;
            offset += positionByteLength;

            let normalOffset = 0;
            if (normalBuffer) {
                combinedBuffer.set(new Uint8Array(normalBuffer.buffer), offset);
                normalOffset = offset;
                offset += normalByteLength;
            }

            let indexOffset = 0;
            let indexComponentType = 0;
            if (indexBuffer) {
                combinedBuffer.set(new Uint8Array(indexBuffer.buffer), offset);
                indexOffset = offset;
                indexComponentType = indexBuffer instanceof Uint16Array ? 5123 : 5125;
            }

            let binary = '';
            const chunkSize = 8192;
            for (let i = 0; i < combinedBuffer.length; i += chunkSize) {
                const chunk = combinedBuffer.subarray(i, Math.min(i + chunkSize, combinedBuffer.length));
                binary += String.fromCharCode.apply(null, chunk);
            }
            const base64 = btoa(binary);
            const dataUri = 'data:application/octet-stream;base64,' + base64;

            const bufferViews = [];
            const accessors = [];

            bufferViews.push({
                buffer: 0,
                byteOffset: positionOffset,
                byteLength: positionByteLength,
                target: 34962
            });
            accessors.push({
                bufferView: 0,
                byteOffset: 0,
                componentType: 5126,
                count: positionBuffer.length / 3,
                type: 'VEC3',
                min: minPos,
                max: maxPos
            });

            let normalAccessorIndex = -1;
            if (normalBuffer) {
                bufferViews.push({
                    buffer: 0,
                    byteOffset: normalOffset,
                    byteLength: normalByteLength,
                    target: 34962
                });
                normalAccessorIndex = accessors.length;
                accessors.push({
                    bufferView: bufferViews.length - 1,
                    byteOffset: 0,
                    componentType: 5126,
                    count: normalBuffer.length / 3,
                    type: 'VEC3'
                });
            }

            let indexAccessorIndex = -1;
            if (indexBuffer) {
                bufferViews.push({
                    buffer: 0,
                    byteOffset: indexOffset,
                    byteLength: indexByteLength,
                    target: 34963
                });
                indexAccessorIndex = accessors.length;
                accessors.push({
                    bufferView: bufferViews.length - 1,
                    byteOffset: 0,
                    componentType: indexComponentType,
                    count: indexBuffer.length,
                    type: 'SCALAR'
                });
            }

            const primitive = {
                attributes: { POSITION: 0 },
                mode: 4
            };
            if (normalAccessorIndex >= 0) {
                primitive.attributes.NORMAL = normalAccessorIndex;
            }
            if (indexAccessorIndex >= 0) {
                primitive.indices = indexAccessorIndex;
            }

            const gltf = {
                asset: { version: '2.0', generator: 'Archaeological Site Viewer' },
                scene: 0,
                scenes: [{ nodes: [0] }],
                nodes: [{ mesh: 0 }],
                meshes: [{ primitives: [primitive] }],
                accessors: accessors,
                bufferViews: bufferViews,
                buffers: [{ byteLength: totalLength, uri: dataUri }]
            };

            const jsonStr = JSON.stringify(gltf, null, 2);
            return new Blob([jsonStr], { type: 'model/gltf+json' });
        }

        function downloadCombinedModel() {
            try {
                const geometry = getCombinedGeometry();
                if (!geometry) {
                    alert('××™×Ÿ ××•×“×œ×™× ×’×œ×•×™×™× ×œ×”×•×¨×“×”');
                    return;
                }

                const posCount = geometry.attributes.position.array.length / 3;

                if (posCount === 0) {
                    alert('×”××•×“×œ ×¨×™×§ - ××™×Ÿ × ×ª×•× ×™× ×œ×”×•×¨×“×”');
                    return;
                }

                const format = document.getElementById('exportFormat').value;
                let blob, filename;

                switch (format) {
                    case 'stl':
                        blob = exportToSTL(geometry);
                        filename = 'combined_model.stl';
                        break;
                    case 'obj':
                        blob = exportToOBJ(geometry);
                        filename = 'combined_model.obj';
                        break;
                    case 'glb':
                        blob = exportToGLTF(geometry, true);
                        filename = 'combined_model.glb';
                        break;
                    case 'gltf':
                        blob = exportToGLTF(geometry, false);
                        filename = 'combined_model.gltf';
                        break;
                }

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();

                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            } catch (error) {
                console.error('Download error:', error);
                alert('×©×’×™××” ×‘×”×•×¨×“×”: ' + error.message);
            }
        }
    </script>
</body>
</html>
